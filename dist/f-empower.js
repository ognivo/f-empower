// Generated by CoffeeScript 1.8.0
define(function() {
  "use strict";

  /*
  F-EMPOWER
  A set of functions to harness the power functional programming in JS.
  Author: Ivan Fedorov <sharp.maestro@gmail.com>
  License: MIT
   */
  var Errors, Reduced, THRESHOLD_LARGE_ARRAY_SIZE, a_contains, a_each, a_filter, a_index_of, a_map, a_reduce, a_reject, a_sum, and2, and_r, any, apply, assign, assign_one, bind, bind_all, build_index, butlast, calc_shortest_length, cat, clone, clone_obj, clonedeep, comma, compact, complement, compose, contains, count, create, debounce, dec, defaults, defaults2, delay, drop, each, each2, each3, each_idx, each_idx2, each_idxn, eachn, equal, equal_array, equal_array_start, equal_object, equal_set, equal_val, exports, extend, filter, filter_fn, filter_obj, filter_obj_1kv, filter_obj_2kv, filter_prop, filter_re, find, find_index, find_index_fn, find_index_obj, find_index_obj_1kv, find_index_obj_2kv, find_index_prop, first, flatten, flattenp, flattenp_recursive, flow, head, inc, index_of, invoke, invokem, is_array, is_atomic, is_date, is_defined, is_empty, is_even, is_function, is_mergeable, is_number, is_object, is_plain_object, is_string, is_zero, jquery_wrap_to_array, keys, last, list, list_compact, make_array, map, map2, map3, mapn, match, matches, merge, mk_regexp, multicall, native_concat, native_index_of, native_locale_compare, native_slice, next, no_operation, not_array, not_contains, not_date, not_defined, not_empty, not_function, not_mergeable, not_number, not_object, not_string, not_zero, o_map, o_match, o_set, omit, partial, partialr, pbind, pick, pick_all, pluck, prelast, prev, pull, push, push_all, range, read, read_1kv, recurse, reduce, reducer, reject, reject_fn, reject_obj, reject_obj_1kv, reject_obj_2kv, reject_prop, remap, remove, remove_at, repeat, repeatf, rest, reverse, second, set, set_difference, set_symmetric_difference, slice, sort, sort_fn, sort_multi, sort_prop, space, splice, str, str_breplace, str_join, str_split, sum2, tail, take, third, throttle, time, to_string, trim, type_of, type_of2, union, unique, unique_by_prop, unshift, vals, varynum, without, write, zip_obj, _clonedeep, _clonedeep2, _compare_crit, _compare_string, _suit_sort;
  THRESHOLD_LARGE_ARRAY_SIZE = 64000;
  Errors = {
    NO_KEY_VALUE_PAIR_IN_HASH: new Error('No key value pair in a criterion hash'),
    NOT_FUNCTION: new TypeError('Something is not function'),
    UNEXPECTED_TYPE: new TypeError('Unexpected type')
  };
  Reduced = function(val) {
    return this.val = val;
  };
  to_string = Object.prototype.toString;
  native_concat = Array.prototype.concat;
  native_index_of = Array.prototype.indexOf;
  native_slice = Array.prototype.slice;
  slice = function(array_or_arguments, start_idx, end_idx) {
    return native_slice.call(array_or_arguments, start_idx, end_idx);
  };
  bind = function(fn, this_arg) {
    return function() {
      return fn.apply(this_arg, arguments);
    };
  };
  partial = function() {
    var args, fn;
    fn = arguments[0];
    args = slice(arguments, 1);
    return function() {
      return fn.apply(null, args.concat(slice(arguments)));
    };
  };
  apply = function(fn, args_list) {
    return fn.apply(this, args_list);
  };
  and2 = function(a, b) {
    return a && b;
  };
  and_r = function(a, b) {
    return (a && b) || new Reduced(false);
  };
  bind_all = function() {
    var props, this_arg;
    props = butlast(arguments);
    this_arg = last(arguments);
    return a_each(props, function(prop) {
      return this_arg[prop] = bind(this_arg[prop], this_arg);
    });
  };
  compose = function() {
    var functions, item, _i, _len;
    functions = arguments;
    for (_i = 0, _len = functions.length; _i < _len; _i++) {
      item = functions[_i];
      if (not_function(item)) {
        throw Errors.NOT_FUNCTION;
      }
    }
    return function() {
      var i, memo;
      memo = arguments;
      i = functions.length;
      while (--i >= 0) {
        memo = [functions[i].apply(null, memo)];
      }
      return first(memo);
    };
  };
  complement = function(predicate) {
    return function() {
      return !(apply(predicate, arguments));
    };
  };
  debounce = function(debounce_timeout, fn) {
    var exec, last_args, last_result, last_timeout_id;
    last_result = void 0;
    last_args = null;
    last_timeout_id = null;
    exec = function() {
      return last_result = apply(fn, last_args);
    };
    return function() {
      last_args = slice(arguments);
      clearTimeout(last_timeout_id);
      last_timeout_id = delay(debounce_timeout, exec);
      return last_result;
    };
  };
  delay = function(delay_ms, fn) {
    if (arguments.length === 1) {
      fn = delay_ms;
      delay_ms = 0;
    }
    return setTimeout(fn, delay_ms);
  };
  flow = function() {
    var functions, item, _i, _len;
    functions = arguments;
    for (_i = 0, _len = functions.length; _i < _len; _i++) {
      item = functions[_i];
      if (not_function(item)) {
        throw Errors.NOT_FUNCTION;
      }
    }
    return function() {
      var i, len, memo;
      memo = arguments;
      len = functions.length;
      i = -1;
      while (++i < len) {
        memo = [functions[i].apply(null, memo)];
      }
      return first(memo);
    };
  };
  multicall = function(fns) {
    fns = compact(fns);
    return function() {
      var fn, _i, _len;
      for (_i = 0, _len = fns.length; _i < _len; _i++) {
        fn = fns[_i];
        fn.apply(this, arguments);
      }
    };
  };
  no_operation = function() {};
  partialr = function(fn, right_args) {
    right_args = slice(arguments, 1);
    return function() {
      return apply(fn, cat(apply(list, arguments), right_args));
    };
  };
  pbind = function(fn) {
    return function() {
      return fn.apply(null, cat([this], slice(arguments)));
    };
  };
  throttle = function(throttle_millis, fn) {
    var last_args, last_result, locked, should_call;
    locked = false;
    should_call = false;
    last_args = null;
    last_result = null;
    return function() {
      var void_main;
      last_args = slice(arguments);
      if (locked) {
        should_call = true;
        return last_result;
      } else {
        locked = true;
        last_result = fn.apply(null, last_args);
        void_main = function() {
          return delay(throttle_millis, function() {
            if (should_call) {
              last_result = fn.apply(null, last_args);
              should_call = false;
              return void_main();
            } else {
              return locked = false;
            }
          });
        };
        void_main();
        return last_result;
      }
    };
  };
  is_array = Array.isArray;
  is_defined = function(subj) {
    return 'undefined' !== (typeof subj);
  };
  is_empty = function(seq) {
    return seq.length === 0;
  };
  is_even = function(num) {
    return 0 === (num % 2);
  };
  is_function = function(candidate) {
    return 'function' === typeof candidate;
  };
  is_number = function(candidate) {
    return 'number' === typeof candidate;
  };
  is_object = function(candidate) {
    return 'object' === typeof candidate;
  };
  is_plain_object = function(subj) {
    var ctor, is_defnd, is_objct, key, latest_key, val;
    is_defnd = 'undefined' !== typeof subj;
    is_objct = is_defnd && ('[object Object]' === to_string.call(subj)) && !(is_function(subj));
    if (!is_objct || (!hasOwnProperty.call(subj, 'constructor') && ((ctor = subj.constructor) && (is_function(ctor)) && !(ctor instanceof ctor)))) {
      return false;
    }
    latest_key = null;
    for (key in subj) {
      val = subj[key];
      latest_key = key;
    }
    return (not_defined(key)) || hasOwnProperty.call(subj, latest_key);
  };
  is_mergeable = function(item) {
    return (is_array(item)) || (is_plain_object(item));
  };
  is_string = function(item) {
    return "string" === (type_of(item));
  };
  is_zero = function(candidate) {
    return candidate === 0;
  };
  not_array = complement(is_array);
  not_date = complement(is_date);
  not_defined = complement(is_defined);
  not_empty = complement(is_empty);
  not_function = complement(is_function);
  not_mergeable = complement(is_mergeable);
  not_number = complement(is_number);
  not_object = complement(is_object);
  not_string = complement(is_string);
  not_zero = complement(is_zero);
  butlast = function(array) {
    return slice(array, 0, (count(array)) - 1);
  };
  cat = function(array) {
    return native_concat.apply(array, slice(arguments, 1));
  };
  contains = function(searched_item, array) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  a_contains = function(array, searched_item) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  a_each = function(array, fn) {
    return each(fn, array);
  };
  a_filter = function(array, fn) {
    return filter(fn, array);
  };
  a_index_of = function(array, item) {
    return array.indexOf(item);
  };
  a_map = function(array, fn) {
    return map(fn, array);
  };
  a_reduce = function(array, fn, val) {
    return reduce(fn, val, array);
  };
  a_reject = function(array, fn) {
    return reject(fn, array);
  };
  any = function(fn, arr) {
    return -1 !== (find_index_fn(fn, arr));
  };
  compact = function(coll) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = coll.length; _i < _len; _i++) {
      item = coll[_i];
      if (item) {
        _results.push(item);
      }
    }
    return _results;
  };
  count = function(array) {
    return array.length;
  };
  drop = function(items_number_to_drop, array_like) {
    return slice(array_like, items_number_to_drop);
  };
  each = function() {
    var args;
    args = arguments;
    switch (count(args)) {
      case 0:
      case 1:
        throw new Error("Each doesn't have a signature of that arity");
        break;
      case 2:
        return each2(args[0], args[1]);
      case 3:
        return each3(args[0], args[1], args[2]);
      default:
        return apply(eachn, args);
    }
  };
  each2 = function(fn, arr) {
    var item, _i, _len;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      fn(item);
    }
  };
  each3 = function(fn, arr1, arr2) {
    var i, length_of_shortest;
    length_of_shortest = Math.min(count(arr1), count(arr2));
    i = -1;
    while (++i < length_of_shortest) {
      fn(arr1[i], arr2[i]);
    }
  };
  calc_shortest_length = function(arrs) {
    return apply(Math.min, map2(count, arrs));
  };
  eachn = function() {
    var args, arrs, fn, i, local_apply, local_pluck, shortest_len;
    args = arguments;
    fn = first(args);
    arrs = rest(args);
    shortest_len = calc_shortest_length(arrs);
    i = -1;
    local_pluck = pluck;
    local_apply = apply;
    while (++i < shortest_len) {
      local_apply(fn, local_pluck(i, arrs));
    }
  };
  each_idx = function() {
    if (arguments.length === 2) {
      return each_idx2(arguments[0], arguments[1]);
    } else {
      return apply(each_idxn, arguments);
    }
  };
  each_idx2 = function(fn, arr) {
    var i, len;
    len = arr.length;
    i = -1;
    while (++i < len) {
      fn(arr[i], i);
    }
  };
  each_idxn = function() {
    var args, arrs, fn, local_apply, local_pluck, shortest_len;
    fn = first(arguments);
    arrs = rest(arguments);
    shortest_len = calc_shortest_length(arrs);
    local_pluck = pluck;
    local_apply = apply;
    while (++i < shortest_len) {
      args = local_pluck(i, arrs);
      args.push(i);
      local_apply(fn, args);
    }
  };
  first = function(array) {
    return array[0];
  };
  filter_fn = function(fn, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (fn(item)) {
        _results.push(item);
      }
    }
    return _results;
  };
  filter_prop = function(prop_name, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!!item[prop_name]) {
        _results.push(item);
      }
    }
    return _results;
  };
  filter_obj_1kv = function(obj, array) {
    var item, key, val, _i, _len, _ref, _results;
    _ref = read_1kv(obj), key = _ref[0], val = _ref[1];
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item[key] === val) {
        _results.push(item);
      }
    }
    return _results;
  };
  filter_obj_2kv = function(obj, array) {
    var item, key1, key2, val1, val2, _i, _len, _ref, _ref1, _results;
    _ref = keys(obj), key1 = _ref[0], key2 = _ref[1];
    _ref1 = [obj[key1], obj[key2]], val1 = _ref1[0], val2 = _ref1[1];
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item[key1] === val1 && item[key2] === val2) {
        _results.push(item);
      }
    }
    return _results;
  };
  filter_obj = function(obj, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (o_match(obj, item)) {
        _results.push(item);
      }
    }
    return _results;
  };
  filter_re = function(regex, strings) {
    var results, string, _i, _len;
    results = [];
    for (_i = 0, _len = strings.length; _i < _len; _i++) {
      string = strings[_i];
      if (regex.test(string)) {
        results.push(string);
      }
    }
    return results;
  };
  filter = function(some_criteria, array) {
    switch (typeof some_criteria) {
      case "string":
        return filter_prop(some_criteria, array);
      case "function":
        return filter_fn(some_criteria, array);
      case "object":
        if ('[object RegExp]' === to_string.call(some_criteria)) {
          return filter_re(some_criteria, array);
        } else {
          switch (count(keys(some_criteria))) {
            case 0:
              throw Errors.NO_KEY_VALUE_PAIR_IN_HASH;
              break;
            case 1:
              return filter_obj_1kv(some_criteria, array);
            case 2:
              return filter_obj_2kv(some_criteria, array);
            default:
              return filter_obj(some_criteria, array);
          }
        }
        break;
      default:
        throw Errors.UNEXPECTED_TYPE;
    }
  };
  find_index_fn = function(fn, array) {
    var idx, item, _i, _len;
    for (idx = _i = 0, _len = array.length; _i < _len; idx = ++_i) {
      item = array[idx];
      if (fn(item)) {
        return idx;
      }
    }
    return -1;
  };
  find_index_prop = function(prop_name, array) {
    var idx, item, _i, _len;
    for (idx = _i = 0, _len = array.length; _i < _len; idx = ++_i) {
      item = array[idx];
      if (item[prop_name]) {
        return idx;
      }
    }
    return -1;
  };
  find_index_obj_1kv = function(obj_with_1kv_pair, array) {
    var idx, item, key, val, _i, _len, _ref;
    _ref = read_1kv(obj_with_1kv_pair), key = _ref[0], val = _ref[1];
    for (idx = _i = 0, _len = array.length; _i < _len; idx = ++_i) {
      item = array[idx];
      if (item[key] === val) {
        return idx;
      }
    }
    return -1;
  };
  find_index_obj_2kv = function(obj_with_2kv_pair, array) {
    var idx, item, key1, key2, val1, val2, _i, _len, _ref, _ref1;
    _ref = keys(obj_with_2kv_pair), key1 = _ref[0], key2 = _ref[1];
    _ref1 = [obj_with_2kv_pair[key1], obj_with_2kv_pair[key2]], val1 = _ref1[0], val2 = _ref1[1];
    for (idx = _i = 0, _len = array.length; _i < _len; idx = ++_i) {
      item = array[idx];
      if (item[key1] === val1 && item[key2] === val2) {
        return idx;
      }
    }
    return -1;
  };
  find_index_obj = function(obj, array) {
    var idx, item, _i, _len;
    for (idx = _i = 0, _len = array.length; _i < _len; idx = ++_i) {
      item = array[idx];
      if (o_match(obj, item)) {
        return idx;
      }
    }
    return -1;
  };
  find_index = function(some_criteria, array) {
    switch (typeof some_criteria) {
      case "string":
        return find_index_prop(some_criteria, array);
      case "function":
        return find_index_fn(some_criteria, array);
      case "object":
        switch (count(keys(some_criteria))) {
          case 0:
            throw Errors.NO_KEY_VALUE_PAIR_IN_HASH;
            break;
          case 1:
            return find_index_obj_1kv(some_criteria, array);
          case 2:
            return find_index_obj_2kv(some_criteria, array);
          default:
            return find_index_obj(some_criteria, array);
        }
        break;
      default:
        throw Errors.UNEXPECTED_TYPE;
    }
  };
  find = function(some_criteria, array) {
    var item_idx;
    item_idx = find_index(some_criteria, array);
    if (item_idx === -1) {
      return;
    }
    return read(item_idx, array);
  };
  flatten = function(arr) {
    return apply(cat, arr);
  };
  index_of = function(item, array) {
    return native_index_of.call(array, item);
  };
  last = function(list) {
    return list[dec(count(list))];
  };
  list = function() {
    var args;
    return (count((args = arguments))) && (slice(args)) || [];
  };
  list_compact = function() {
    var arg, result, _i, _len;
    result = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      arg = arguments[_i];
      if (!!arg) {
        result.push(arg);
      }
    }
    return result;
  };
  next = function(arr, item) {
    return arr[(index_of(item, arr)) + 1];
  };
  prev = function(arr, item) {
    return arr[(index_of(item, arr)) - 1];
  };
  type_of = function(mixed) {
    return typeof mixed;
  };
  type_of2 = function(val) {
    return to_string.call(val);
  };
  sort = function(criterion, arr) {
    switch (count(arguments)) {
      case 1:
        return criterion.sort();
      case 2:
        if (2 > (count(arr))) {
          return slice(arr);
        }
        switch (type_of(criterion)) {
          case "string":
            return sort_prop(criterion, arr);
          case "array":
            return sort_multi(criterion, arr);
          case "function":
            return sort_fn(criterion, arr);
        }
    }
  };
  sort_prop = function(prop, arr) {
    var compare_fn, need_string_comparison, sort_suitable_arr;
    sort_suitable_arr = map(partial(_suit_sort, prop), arr);
    need_string_comparison = is_string(arr[0][prop]);
    compare_fn = need_string_comparison && _compare_string || _compare_crit;
    return pluck('val', sort_suitable_arr.sort(compare_fn));
  };
  _suit_sort = function(prop, obj) {
    return {
      val: obj,
      criteria: obj[prop]
    };
  };
  _compare_crit = function(obj1, obj2) {
    return obj1.criteria - obj2.criteria;
  };
  native_locale_compare = String.prototype.localeCompare;
  _compare_string = function(obj1, obj2) {
    return native_locale_compare.call(obj1.criteria, obj2.criteria);
  };
  sort_multi = function(props_arr, arr) {};
  sort_fn = function(compare_fn, arr) {
    return arr.sort(compare_fn);
  };
  map = function() {
    var arg0, args;
    args = arguments;
    arg0 = args[0];
    switch (count(args)) {
      case 0:
      case 1:
        throw new Error("Map doesn't have a signature of that arity");
        break;
      case 2:
        switch (typeof arg0) {
          case 'function':
            return map2(arg0, args[1]);
          case 'string':
            return pluck(arg0, args[1]);
          case 'object':
            return o_map(arg0, args[1]);
        }
        break;
      case 3:
        return map3(arg0, args[1], args[2]);
      default:
        return apply(mapn, args);
    }
  };
  make_array = function(len) {
    return len > THRESHOLD_LARGE_ARRAY_SIZE && [] || new Array(len);
  };
  map2 = function(fn, arr) {
    var i, len, result;
    i = -1;
    len = count(arr);
    result = make_array(len);
    while (++i < len) {
      result[i] = fn(arr[i]);
    }
    return result;
  };
  map3 = function(fn, arr1, arr2) {
    var i, length_of_shortest, result;
    length_of_shortest = Math.min(count(arr1), count(arr2));
    i = -1;
    result = make_array(length_of_shortest);
    while (++i < length_of_shortest) {
      result[i] = fn(arr1[i], arr2[i]);
    }
    return result;
  };
  mapn = function() {
    var args, arrs, fn, i, local_apply, local_pluck, result, shortest_len;
    args = arguments;
    fn = first(args);
    arrs = rest(args);
    shortest_len = apply(Math.min, map2(count, arrs));
    i = -1;
    local_pluck = pluck;
    local_apply = apply;
    result = make_array(shortest_len);
    while (++i < shortest_len) {
      result[i] = local_apply(fn, local_pluck(i, arrs));
    }
    return result;
  };
  not_contains = complement(contains);
  prelast = function(array) {
    return array[(count(array)) - 2];
  };
  push = function(arr, item) {
    arr.push(item);
    return arr;
  };
  push_all = function(arr, items_to_push_arr) {
    arr.push.apply(arr, items_to_push_arr);
    return arr;
  };
  reduce = function(fn, val, array) {
    var idx, len;
    idx = -1;
    if (!array && (is_array(val))) {
      array = val;
      val = fn(first(array), second(array));
      idx = 1;
    }
    len = count(array);
    while (++idx < len && (!val || val.constructor !== Reduced)) {
      val = fn(val, array[idx]);
    }
    if (val && val.constructor === Reduced) {
      return val.val;
    } else {
      return val;
    }
  };
  reducer = function(fn, val, arr) {
    var idx;
    idx = -1;
    if (!arr && (is_array(val))) {
      arr = val;
      val = fn(last(arr), prelast(arr));
      idx = (count(arr)) - 2;
    } else {
      idx = count(arr);
    }
    while (--idx > -1) {
      val = fn(val, arr[idx]);
    }
    return val;
  };
  reject_fn = function(fn, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!(fn(item))) {
        _results.push(item);
      }
    }
    return _results;
  };
  reject_prop = function(prop_name, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!item[prop_name]) {
        _results.push(item);
      }
    }
    return _results;
  };
  reject_obj_1kv = function(one_kv_pair_object, array) {
    var item, key, val, _i, _len, _ref, _results;
    _ref = read_1kv(one_kv_pair_object), key = _ref[0], val = _ref[1];
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item[key] !== val) {
        _results.push(item);
      }
    }
    return _results;
  };
  reject_obj_2kv = function(two_kv_pairs_object, array) {
    var item, key1, key2, val1, val2, _i, _len, _ref, _ref1, _results;
    _ref = keys(two_kv_pairs_object), key1 = _ref[0], key2 = _ref[1];
    _ref1 = [two_kv_pairs_object[key1], two_kv_pairs_object[key2]], val1 = _ref1[0], val2 = _ref1[1];
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!(item[key1] === val1 && item[key2] === val2)) {
        _results.push(item);
      }
    }
    return _results;
  };
  reject_obj = function(object, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!(o_match(object, item))) {
        _results.push(item);
      }
    }
    return _results;
  };
  reject = function(some_criteria, array) {
    switch (typeof some_criteria) {
      case "string":
        return reject_prop(some_criteria, array);
      case "function":
        return reject_fn(some_criteria, array);
      case "object":
        switch (count(keys(some_criteria))) {
          case 0:
            throw Errors.NO_KEY_VALUE_PAIR_IN_HASH;
            break;
          case 1:
            return reject_obj_1kv(some_criteria, array);
          case 2:
            return reject_obj_2kv(some_criteria, array);
          default:
            return reject_obj(some_criteria, array);
        }
        break;
      default:
        throw Errors.UNEXPECTED_TYPE;
    }
  };
  remap = function(fn, arr) {
    var item, item_idx, prop, _i, _j, _len, _len1;
    switch (arguments.length) {
      case 2:
        for (item_idx = _i = 0, _len = arr.length; _i < _len; item_idx = ++_i) {
          item = arr[item_idx];
          arr[item_idx] = fn(item);
        }
        break;
      case 3:
        fn = arguments[0], prop = arguments[1], arr = arguments[2];
        for (item_idx = _j = 0, _len1 = arr.length; _j < _len1; item_idx = ++_j) {
          item = arr[item_idx];
          arr[item_idx][prop] = fn(item[prop]);
        }
    }
    return arr;
  };
  remove = function(item, arr) {
    var idx;
    idx = index_of(item, arr);
    return idx !== -1 && (remove_at(idx, arr));
  };
  remove_at = function(idx, arr) {
    return splice(arr, idx, 1);
  };
  repeat = function(times, value) {
    var _results;
    _results = [];
    while (--times > -1) {
      _results.push(value);
    }
    return _results;
  };
  repeatf = function(times, fn) {
    var _results;
    _results = [];
    while (--times > -1) {
      _results.push(fn());
    }
    return _results;
  };
  rest = function(arr) {
    return slice(arr, 1);
  };
  reverse = function(arr) {
    var i, j, len, res;
    len = arr.length;
    i = 0;
    j = len;
    res = new Array(len);
    while (--j > -1) {
      res[i] = arr[j];
      i += 1;
    }
    return res;
  };
  splice = bind(Function.prototype.call, Array.prototype.splice);
  second = function(array) {
    return array[1];
  };
  set_difference = function(set_a, set_b) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = set_a.length; _i < _len; _i++) {
      item = set_a[_i];
      if (not_contains(item, set_b)) {
        _results.push(item);
      }
    }
    return _results;
  };
  set_symmetric_difference = function(set_a, set_b) {
    return [set_difference(set_a, set_b), set_difference(set_b, set_a)];
  };
  take = function(items_number_to_take, array_like) {
    return slice(array_like, 0, items_number_to_take);
  };
  third = function(arr) {
    return arr[2];
  };
  union = function(arr1, arr2) {
    var item, result, _i, _len;
    result = arr1.slice();
    for (_i = 0, _len = arr2.length; _i < _len; _i++) {
      item = arr2[_i];
      if (!(contains(item, arr1))) {
        result.push(item);
      }
    }
    return result;
  };
  unshift = function(arr, item) {
    arr.unshift(item);
    return arr;
  };
  without = function(item, arr) {
    remove(item, arr);
    return arr;
  };
  invoke = function(method_name, coll) {
    var args_count, i, item, len, method_args, results;
    args_count = count(arguments);
    if (args_count >= 3) {
      method_args = slice(arguments, 1, args_count - 1);
      coll = last(arguments);
    }
    len = count(coll);
    results = make_array(len);
    i = -1;
    if (args_count >= 3) {
      while (++i < len) {
        item = coll[i];
        results[i] = item[method_name].apply(item, method_args);
      }
    } else {
      while (++i < len) {
        item = coll[i];
        results[i] = item[method_name]();
      }
    }
    return results;
  };
  invokem = function(method_name, coll) {
    var args_count, i, item, len, method_args;
    args_count = count(arguments);
    if (args_count >= 3) {
      method_args = slice(arguments, 1, args_count - 1);
      coll = last(arguments);
    }
    len = count(coll);
    i = -1;
    if (args_count >= 3) {
      while (++i < len) {
        item = coll[i];
        item[method_name].apply(item, method_args);
      }
    } else {
      while (++i < len) {
        coll[i][method_name]();
      }
    }
  };
  pluck = function(key, coll) {
    var i, len, result;
    len = count(coll);
    result = make_array(len);
    i = -1;
    while (++i < len) {
      result[i] = coll[i][key];
    }
    return result;
  };
  varynum = function(numbers_arr, start_with_one) {
    var number, variator, _i, _len, _results;
    variator = start_with_one && -1 || 1;
    _results = [];
    for (_i = 0, _len = numbers_arr.length; _i < _len; _i++) {
      number = numbers_arr[_i];
      variator *= -1;
      _results.push(number * variator);
    }
    return _results;
  };
  write = function(dst_coll, prop_name, src_coll) {
    var dst, idx, src, _i, _len;
    for (idx = _i = 0, _len = dst_coll.length; _i < _len; idx = ++_i) {
      dst = dst_coll[idx];
      src = src_coll[idx];
      dst[prop_name] = src;
    }
    return dst_coll;
  };
  unique_by_prop = function(prop_name, arr) {
    var help_hash, out;
    help_hash = {};
    out = [];
    a_each(arr, function(item) {
      var prop_val;
      prop_val = item[prop_name];
      if (!help_hash[prop_val]) {
        help_hash[prop_val] = true;
        return out.push(item);
      }
    });
    return out;
  };
  unique = unique_by_prop;
  assign = function(dest, sources) {
    if (dest == null) {
      dest = {};
    }
    sources = drop(1, arguments);
    each(partial(assign_one, dest), sources);
    return dest;
  };
  assign_one = function(dest, src) {
    var key, val;
    for (key in src) {
      val = src[key];
      dest[key] = val;
    }
    return dest;
  };
  build_index = function(index_prop, list_to_index, accumulator) {
    var item, _i, _len;
    if (accumulator == null) {
      accumulator = {};
    }
    for (_i = 0, _len = list_to_index.length; _i < _len; _i++) {
      item = list_to_index[_i];
      accumulator[item[index_prop]] = item;
    }
    return accumulator;
  };
  clone_obj = function(obj) {
    var key, res, val;
    res = {};
    for (key in obj) {
      val = obj[key];
      res[key] = val;
    }
    return res;
  };
  clone = function(data) {
    if (is_object(data)) {
      if (is_array(data)) {
        return slice(data);
      } else {
        return clone_obj(data);
      }
    } else {
      throw Errors.UNEXPECTED_TYPE;
    }
  };
  clonedeep = function(src) {
    var dst, stack_dst, stack_src;
    return _clonedeep(src, dst = (is_array(src)) && [] || {}, stack_dst = [dst], stack_src = [src]);
  };
  is_atomic = function(val) {
    switch (type_of2(val)) {
      case '[object Object]':
      case '[object Array]':
      case '[object Date]':
        return false;
      default:
        return true;
    }
  };
  is_date = function(val) {
    return '[object Date]' === (type_of2(val));
  };
  _clonedeep = function(src, dst, stack_dst, stack_src) {
    var child_dst, key, val, val_idx;
    for (key in src) {
      val = src[key];
      if (is_atomic(val)) {
        dst[key] = val;
      } else if (is_date(val)) {
        dst[key] = new Date(val.getTime());
      } else {
        val_idx = index_of(val, stack_src);
        if (val_idx === -1) {
          dst[key] = child_dst = (is_array(val)) && [] || {};
          stack_src.push(val);
          stack_dst.push(child_dst);
          _clonedeep(val, child_dst, stack_dst, stack_src);
        } else {
          dst[key] = stack_dst[val_idx];
        }
      }
    }
    return dst;
  };
  _clonedeep2 = function(src) {
    var child_dst, cur_dst, cur_key_idx, cur_keys, cur_src, dst, key, stack_act, stack_dst, stack_src, val, val_idx, _ref;
    dst = (is_array(src)) && [] || {};
    cur_src = src;
    cur_dst = dst;
    stack_src = [src];
    stack_dst = [dst];
    stack_act = [];
    cur_keys = (is_array(cur_src)) && (range(count(cur_src))) || (reverse(keys(cur_src)));
    cur_key_idx = count(cur_keys);
    while (--cur_key_idx >= 0) {
      key = cur_keys[cur_key_idx];
      val = cur_src[key];
      if (is_atomic(val)) {
        cur_dst[key] = val;
      } else if (is_date(val)) {
        cur_dst[key] = new Date(val.getTime());
      } else {
        val_idx = index_of(val, stack_src);
        if (val_idx === -1) {
          child_dst = (is_array(val)) && [] || {};
          cur_dst[key] = child_dst;
          stack_act.push([cur_src, cur_dst, cur_keys, cur_key_idx]);
          cur_src = val;
          cur_dst = child_dst;
          cur_keys = (is_array(cur_src)) && (range(count(cur_src))) || (reverse(keys(cur_src)));
          cur_key_idx = count(cur_keys);
          stack_src.push(cur_src);
          stack_dst.push(cur_dst);
        } else {
          cur_dst[key] = stack_dst[val_idx];
        }
      }
      while ((is_zero(cur_key_idx)) && (not_zero(count(stack_act)))) {
        _ref = stack_act.pop(), cur_src = _ref[0], cur_dst = _ref[1], cur_keys = _ref[2], cur_key_idx = _ref[3];
      }
    }
    return dst;
  };
  create = function(ctor, arg) {
    return new ctor(arg);
  };
  defaults = function(dest) {
    if (dest == null) {
      dest = {};
    }
    return reduce(defaults2, dest, rest(arguments));
  };
  defaults2 = function(dest, source) {
    var key, val;
    for (key in source) {
      val = source[key];
      if ('undefined' === typeof dest[key]) {
        dest[key] = val;
      }
    }
    return dest;
  };
  equal = function(o1, o2) {
    if ((is_array(o1)) && (is_array(o2))) {
      return equal_array(o1, o2);
    } else {
      return equal_object(o1, o2);
    }
  };
  equal_array = function(arr1, arr2) {
    var len1, len2;
    len1 = count(arr1);
    len2 = count(arr2);
    return ((0 === len1) && (0 === len2)) || ((len1 === len2) && (equal_array_start(arr1, arr2)));
  };
  equal_array_start = function(arr1, arr2) {
    return reduce(and_r, true, map(equal_val, arr1, arr2));
  };
  equal_object = function(o1, o2) {
    var keys1, keys2, vals1, vals2;
    keys1 = keys(o1);
    keys2 = keys(o2);
    if (keys1.length === keys2.length && (equal_set(keys1, keys2))) {
      vals1 = o_map(o1, keys1);
      vals2 = o_map(o2, keys1);
      return equal_array_start(vals1, vals2);
    } else {
      return false;
    }
  };
  equal_set = function(keyset1, keyset2) {
    var diff1, diff2, _ref;
    _ref = set_symmetric_difference(keyset1, keyset2), diff1 = _ref[0], diff2 = _ref[1];
    return (is_empty(diff1)) && (is_empty(diff2));
  };
  equal_val = function(v1, v2) {
    return v1 === v2;
  };
  extend = function(extended, extension) {
    return assign(Object.create(extended), extension);
  };
  flattenp_recursive = function(key, root, accumulator) {
    var children, son, _i, _len;
    push_all(accumulator, root[key]);
    if (children = root[key]) {
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        son = children[_i];
        flattenp_recursive(key, son, accumulator);
      }
    }
    return accumulator;
  };
  flattenp = function(key, root, _arg) {
    var accumulator, include_root;
    include_root = (_arg != null ? _arg : {
      include_root: true
    }).include_root;
    accumulator = include_root && [root] || [];
    return flattenp_recursive(key, root, accumulator);
  };
  keys = function(hash) {
    return Object.keys(hash);
  };
  merge = function(dst, src) {
    var call_stack, cur_dst, cur_key_idx, cur_keys, cur_src, key, src_stack, val, val_idx, _ref;
    call_stack = [];
    src_stack = [];
    cur_dst = dst;
    cur_src = src;
    cur_keys = keys(src);
    cur_key_idx = count(cur_keys);
    while (--cur_key_idx >= 0) {
      key = cur_keys[cur_key_idx];
      val = cur_src[key];
      if ((not_defined(cur_dst[key])) || (not_mergeable(val))) {
        cur_dst[key] = val;
        if (is_mergeable(val)) {
          src_stack.push(val);
        }
      } else {
        val_idx = index_of(val, src_stack);
        if (val_idx === -1) {
          call_stack.push([cur_dst, cur_src, cur_keys, cur_key_idx]);
          src_stack.push(val);
          cur_dst = cur_dst[key];
          cur_src = cur_src[key];
          cur_keys = keys(cur_src);
          cur_key_idx = count(cur_keys);
        }
      }
      while ((is_zero(cur_key_idx)) && (not_empty(call_stack))) {
        _ref = call_stack.pop(), cur_dst = _ref[0], cur_src = _ref[1], cur_keys = _ref[2], cur_key_idx = _ref[3];
      }
    }
    return dst;
  };
  omit = function(obj, props) {
    var key, res, val;
    res = {};
    props = rest(arguments);
    for (key in obj) {
      val = obj[key];
      if (not_contains(key, props)) {
        res[key] = val;
      }
    }
    return res;
  };
  o_map = function(hash, keys_list) {
    var key, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = keys_list.length; _i < _len; _i++) {
      key = keys_list[_i];
      _results.push(hash[key]);
    }
    return _results;
  };
  o_match = function(criteria_obj, subject) {
    var key, val;
    for (key in criteria_obj) {
      val = criteria_obj[key];
      if (subject[key] !== val) {
        return false;
      }
    }
    return true;
  };
  o_set = function(obj, key, val) {
    return obj[key] = val;
  };
  pull = function(key, hash) {
    var val;
    val = hash[key];
    delete hash[key];
    return val;
  };
  pick = function(obj, props) {
    return pick_all(obj, rest(arguments));
  };
  pick_all = function(obj, props) {
    var prop, res, _i, _len;
    res = {};
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      if (obj[prop] !== void 0) {
        res[prop] = obj[prop];
      }
    }
    return res;
  };
  vals = function(hash) {
    return o_map(hash, keys(hash));
  };
  zip_obj = function(keys, vals) {
    var obj;
    obj = {};
    each(partial(o_set, obj), keys, vals);
    return obj;
  };
  head = function(chars_to_take, str) {
    return str.substr(0, chars_to_take);
  };
  match = function(regexp, source_str) {
    return source_str.match(regexp);
  };
  matches = function(regexp, str) {
    if ('string' === (type_of(regexp))) {
      return (mk_regexp(regexp)).test(str);
    } else {
      return regexp.test(str);
    }
  };
  comma = function() {
    return str_join(',', slice(arguments));
  };
  space = function() {
    return str_join(' ', slice(arguments));
  };
  str = function() {
    return str_join('', slice(arguments));
  };
  str_breplace = function(map, str) {
    var regex;
    regex = mk_regexp(str_join('|', keys(map)), 'ig');
    return str.replace(regex, function(seq) {
      return map[seq] || seq;
    });
  };
  str_join = function(join_string, array_to_join) {
    return array_to_join.join(join_string);
  };
  str_split = function(split_str, string_to_split) {
    return string_to_split.split(split_str);
  };
  tail = function(chars_to_drop, str) {
    return str.substr(chars_to_drop);
  };
  trim = function(str) {
    return str.trim();
  };
  dec = function(num) {
    return num - 1;
  };
  inc = function(num) {
    return num + 1;
  };
  jquery_wrap_to_array = function(jquery_wrap) {
    var i, wrap_len, _results;
    wrap_len = count(jquery_wrap);
    i = -1;
    _results = [];
    while (++i < wrap_len) {
      _results.push(jquery_wrap.eq(i));
    }
    return _results;
  };
  mk_regexp = function(rx_str, rx_settings) {
    rx_settings = rx_settings || "";
    return new RegExp(rx_str, rx_settings);
  };
  range = function(start_idx, end_idx, step) {
    var array, i, length;
    switch (count(arguments)) {
      case 1:
        end_idx = start_idx;
        start_idx = 0;
        step = 1;
        break;
      case 2:
        step = 1;
        break;
      case 3:
        break;
      default:
        throw new Error('Bad arguments length, available signatures are for arguments length 1, 2 and 3');
    }
    length = Math.ceil((Math.abs(end_idx - start_idx)) / step);
    array = new Array(length);
    start_idx -= step;
    i = -1;
    while (++i < length) {
      array[i] = (start_idx += step);
    }
    return array;
  };
  read = function(prop_name, hash) {
    return hash[prop_name];
  };
  read_1kv = function(obj_with_1kv_pair) {
    var key;
    key = first(keys(obj_with_1kv_pair));
    return [key, read(key, obj_with_1kv_pair)];
  };

  /*
  This is a function that iterates with another function 
  over the nodes of a tree structure.
  @param fn {function} function that operates on the node.
    signature: son, parent, son_idx, depth
  @param root {hash} a tree whose children lie in the children
    list (i.e. ordered collection).
  @param depth: indicates depth of recursion
   */
  recurse = function(fn, root, depth) {
    var children, idx, son, _i, _j, _len, _len1;
    if (depth == null) {
      depth = 0;
    }
    children = root.children;
    depth++;
    for (idx = _i = 0, _len = children.length; _i < _len; idx = ++_i) {
      son = children[idx];
      fn(son, root, idx, depth);
    }
    for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
      son = children[_j];
      recurse(fn, son, depth);
    }
    return root;
  };
  sum2 = function(a, b) {
    return a + b;
  };
  a_sum = partial(reduce, sum2);
  set = function(prop_name, val, hash) {
    return hash[prop_name] = val;
  };
  time = function(fn) {
    var time_end, time_start;
    time_start = Date.now();
    fn();
    time_end = Date.now();
    return time_end - time_start;
  };
  exports = ("undefined" !== typeof module) && module.exports || {};
  exports.Reduced = Reduced;
  exports.a_contains = a_contains;
  exports.a_each = a_each;
  exports.a_filter = a_filter;
  exports.a_index_of = a_index_of;
  exports.a_map = a_map;
  exports.a_reduce = a_reduce;
  exports.a_reject = a_reject;
  exports.a_sum = a_sum;
  exports.and2 = and2;
  exports.any = any;
  exports.assign = assign;
  exports.apply = apply;
  exports.bind = bind;
  exports.bind_all = bind_all;
  exports.build_index = build_index;
  exports.butlast = butlast;
  exports.cat = cat;
  exports.clone = clone;
  exports.clonedeep = clonedeep;
  exports.clonedeep2 = _clonedeep2;
  exports.comma = comma;
  exports.compact = compact;
  exports.compose = compose;
  exports.complement = complement;
  exports.concat = cat;
  exports.contains = contains;
  exports.count = count;
  exports.create = create;
  exports.debounce = debounce;
  exports.dec = dec;
  exports.defaults = defaults;
  exports.delay = delay;
  exports.detect = find;
  exports.drop = drop;
  exports.each = each;
  exports.each_idx = each_idx;
  exports.equal = equal;
  exports.equal_array_start = equal_array_start;
  exports.equal_val = equal_val;
  exports.extend = extend;
  exports.fastbind = bind;
  exports.first = first;
  exports.filter = filter;
  exports.filter_fn = filter_fn;
  exports.filter_obj = filter_obj;
  exports.filter_obj_1kv = filter_obj_1kv;
  exports.filter_obj_2kv = filter_obj_2kv;
  exports.filter_prop = filter_prop;
  exports.filter_re = filter_re;
  exports.find = find;
  exports.find_index = find_index;
  exports.find_index_fn = find_index_fn;
  exports.find_index_prop = find_index_prop;
  exports.find_index_obj_1kv = find_index_obj_1kv;
  exports.find_index_obj_2kv = find_index_obj_2kv;
  exports.find_index_obj = find_index_obj;
  exports.flatten = flatten;
  exports.flattenp = flattenp;
  exports.flow = flow;
  exports.get = read;
  exports.head = head;
  exports.inc = inc;
  exports.index_of = index_of;
  exports.invoke = invoke;
  exports.invokem = invokem;
  exports.is_array = is_array;
  exports.is_date = is_date;
  exports.is_defined = is_defined;
  exports.is_empty = is_empty;
  exports.is_even = is_even;
  exports.is_function = is_function;
  exports.is_mergeable = is_mergeable;
  exports.is_number = is_number;
  exports.is_object = is_object;
  exports.is_plain_object = is_plain_object;
  exports.is_string = is_string;
  exports.is_zero = is_zero;
  exports.jquery_wrap_to_array = jquery_wrap_to_array;
  exports.j2a = jquery_wrap_to_array;
  exports.keys = keys;
  exports.last = last;
  exports.list = list;
  exports.list_compact = list_compact;
  exports.map = map;
  exports.match = match;
  exports.matches = matches;
  exports.merge = merge;
  exports.mk_regexp = mk_regexp;
  exports.multicall = multicall;
  exports.next = next;
  exports.no_operation = no_operation;
  exports.noop = no_operation;
  exports.not_array = not_array;
  exports.not_date = not_date;
  exports.not_defined = not_defined;
  exports.not_empty = not_empty;
  exports.not_function = not_function;
  exports.not_number = not_number;
  exports.not_object = not_object;
  exports.not_string = not_string;
  exports.not_zero = not_zero;
  exports.omit = omit;
  exports.o_map = o_map;
  exports.o_match = o_match;
  exports.partial = partial;
  exports.pbind = pbind;
  exports.pt = partial;
  exports.ptr = partialr;
  exports.partialr = partialr;
  exports.pick = pick;
  exports.pick_all = pick_all;
  exports.pipeline = flow;
  exports.pluck = pluck;
  exports.prev = prev;
  exports.pull = pull;
  exports.push = push;
  exports.push_all = push_all;
  exports.range = range;
  exports.read = read;
  exports.recurse = recurse;
  exports.reduce = reduce;
  exports.reducer = reducer;
  exports.reject = reject;
  exports.reject_fn = reject_fn;
  exports.reject_obj = reject_obj;
  exports.reject_obj_1kv = reject_obj_1kv;
  exports.reject_obj_2kv = reject_obj_2kv;
  exports.reject_prop = reject_prop;
  exports.remap = remap;
  exports.remove = remove;
  exports.remove_at = remove_at;
  exports.repeat = repeat;
  exports.repeatf = repeatf;
  exports.rest = rest;
  exports.reverse = reverse;
  exports.second = second;
  exports.set = set;
  exports.set_difference = set_difference;
  exports.set_symmetric_difference = set_symmetric_difference;
  exports.slice = slice;
  exports.sort = sort;
  exports.space = space;
  exports.splice = splice;
  exports.str = str;
  exports.str_breplace = str_breplace;
  exports.str_join = str_join;
  exports.str_split = str_split;
  exports.sum2 = sum2;
  exports.sumn = flow(list, partial(reduce, sum2));
  exports.take = take;
  exports.tail = tail;
  exports.third = third;
  exports.throttle = throttle;
  exports.time = time;
  exports.trim = trim;
  exports.union = union;
  exports.unique = unique;
  exports.unshift = unshift;
  exports.vals = vals;
  exports.varynum = varynum;
  exports.without = without;
  exports.write = write;
  exports.zip_obj = zip_obj;
  return exports;
});
