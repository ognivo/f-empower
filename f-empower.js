// Generated by CoffeeScript 1.7.1
var wrapper;

wrapper = function() {
  var bind, cat, contains, count, each, first, invoke, keys, list_compact, map, match, mk_regexp, native_slice, not_empty, partial, recurse, remap, slice, str, str_breplace, str_join, varynum;
  native_slice = Array.prototype.slice;
  slice = function(array_or_arguments, idx) {
    return native_slice.call(array_or_arguments, idx);
  };
  bind = function(fn, this_arg) {
    var other_args;
    other_args = slice(arguments, 2);
    return arguments.length <= 2 && (function() {
      return fn.apply(this_arg, arguments);
    }) || (function() {
      return fn.apply(this_arg, other_args.concat(slice(arguments)));
    });
  };
  partial = function() {
    var args, fn;
    fn = arguments[0];
    args = slice(arguments, 1);
    return function() {
      return fn.apply(null, args.concat(slice(arguments)));
    };
  };
  not_empty = function(list) {
    return list.length > 0;
  };
  first = function(array) {
    return array[0];
  };
  cat = function(array) {
    return array.concat.apply(array, slice(arguments, 1));
  };
  contains = function(searched_item, array) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  count = function(array) {
    return array.length;
  };
  each = function(fn, array) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      fn(item);
    }
  };
  list_compact = function() {
    var arg, result, _i, _len;
    result = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      arg = arguments[_i];
      if (!!arg) {
        result.push(arg);
      }
    }
    return result;
  };
  map = function(fn, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      _results.push(fn(item));
    }
    return _results;
  };
  remap = function(fn, array) {
    var item, item_idx, _i, _len;
    for (item_idx = _i = 0, _len = array.length; _i < _len; item_idx = ++_i) {
      item = array[item_idx];
      array[item_idx] = fn(item);
    }
    return array;
  };
  invoke = function(method_name, collection) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = collection.length; _i < _len; _i++) {
      item = collection[_i];
      _results.push(item[method_name]());
    }
    return _results;
  };
  varynum = function(numbers, start_with_one) {
    var number, variator, _i, _len, _results;
    variator = start_with_one && -1 || 1;
    _results = [];
    for (_i = 0, _len = numbers.length; _i < _len; _i++) {
      number = numbers[_i];
      variator *= -1;
      _results.push(number * variator);
    }
    return _results;
  };
  keys = function() {
    return Object.keys.apply(Object, arguments);
  };
  match = function(source_str, regexp) {
    return source_str.match(regexp);
  };
  str = function() {
    return Array.prototype.join.call(arguments, ' ');
  };
  str_breplace = function(map, str) {
    var regex;
    regex = mk_regexp(str_join('|', keys(map)), 'ig');
    return str.replace(regex, function(seq) {
      return map[seq] || seq;
    });
  };
  str_join = function(join_string, array_to_join) {
    return array_to_join.join(join_string);
  };
  mk_regexp = function(rx_str, rx_settings) {
    rx_settings = rx_settings || "";
    return new RegExp(rx_str, rx_settings);
  };

  /*
  This is a function that iterates with another function 
  over the nodes of a tree structure.
  @param func {function} function that operates on the node.
    signature: son, parent, son_idx, depth
  @param root {hash} a tree whose children lie in the sons
    list (i.e. ordered collection).
  @param depth: indicates depth of recursion
   */
  recurse = function(func, root, depth) {
    var idx, son, sons, _i, _j, _len, _len1;
    if (depth == null) {
      depth = 0;
    }
    sons = root.sons;
    for (idx = _i = 0, _len = sons.length; _i < _len; idx = ++_i) {
      son = sons[idx];
      func(son, root, idx, depth + 1);
    }
    for (_j = 0, _len1 = sons.length; _j < _len1; _j++) {
      son = sons[_j];
      recurse(func, son, depth + 1);
    }
    return root;
  };
  return {
    bind: bind,
    cat: cat,
    contains: contains,
    count: count,
    each: each,
    fastbind: bind,
    first: first,
    invoke: invoke,
    keys: keys,
    list_compact: list_compact,
    map: map,
    match: match,
    mk_regexp: mk_regexp,
    not_empty: not_empty,
    partial: partial,
    recurse: recurse,
    remap: remap,
    slice: slice,
    str: str,
    str_breplace: str_breplace,
    str_join: str_join,
    varynum: varynum
  };
};

if (('undefined' !== typeof define) && define.amd) {
  define(wrapper);
} else if (('undefined' !== typeof module) && module.exports) {
  module.exports = wrapper();
}
