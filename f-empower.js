// Generated by CoffeeScript 1.7.1
(function() {
  var wrapper;

  wrapper = function() {
    var Errors, apply, bind, cat, complement, compose, contains, count, each, first, flow, invoke, is_empty, is_function, keys, last, list_compact, map, match, mk_regexp, native_slice, not_empty, not_function, partial, recurse, remap, slice, str, str_breplace, str_join, varynum;
    Errors = {
      NOT_FUNCTION: new TypeError('Something is not function')
    };
    native_slice = Array.prototype.slice;
    slice = function(array_or_arguments, idx) {
      return native_slice.call(array_or_arguments, idx);
    };
    bind = function(fn, this_arg) {
      var other_args;
      other_args = slice(arguments, 2);
      return arguments.length <= 2 && (function() {
        return fn.apply(this_arg, arguments);
      }) || (function() {
        return fn.apply(this_arg, other_args.concat(slice(arguments)));
      });
    };
    partial = function() {
      var args, fn;
      fn = arguments[0];
      args = slice(arguments, 1);
      return function() {
        return fn.apply(null, args.concat(slice(arguments)));
      };
    };
    apply = function(fn, args_list) {
      return fn.apply(null, args_list);
    };
    compose = function() {
      var functions, item, _i, _len;
      functions = arguments;
      for (_i = 0, _len = functions.length; _i < _len; _i++) {
        item = functions[_i];
        if (not_function(item)) {
          throw Errors.NOT_FUNCTION;
        }
      }
      return function() {
        var i, memo;
        memo = arguments;
        i = functions.length;
        while (--i >= 0) {
          memo = [functions[i].apply(null, memo)];
        }
        return first(memo);
      };
    };
    complement = function(predicate) {
      return function() {
        return !(apply(predicate, arguments));
      };
    };
    flow = function() {
      var functions, item, _i, _len;
      functions = arguments;
      for (_i = 0, _len = functions.length; _i < _len; _i++) {
        item = functions[_i];
        if (not_function(item)) {
          throw Errors.NOT_FUNCTION;
        }
      }
      return function() {
        var i, len, memo;
        memo = arguments;
        len = functions.length;
        i = -1;
        while (++i < len) {
          memo = [functions[i].apply(null, memo)];
        }
        return first(memo);
      };
    };
    is_empty = function(list) {
      return list.length === 0;
    };
    is_function = function(candidate) {
      return 'function' === typeof candidate;
    };
    not_empty = complement(is_empty);
    not_function = complement(is_function);
    first = function(array) {
      return array[0];
    };
    cat = function(array) {
      return array.concat.apply(array, slice(arguments, 1));
    };
    contains = function(searched_item, array) {
      var item, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (searched_item === item) {
          return true;
        }
      }
      return false;
    };
    count = function(array) {
      return array.length;
    };
    each = function(fn, array) {
      var item, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        fn(item);
      }
    };
    last = function(list) {
      return list[list.length - 1];
    };
    list_compact = function() {
      var arg, result, _i, _len;
      result = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        if (!!arg) {
          result.push(arg);
        }
      }
      return result;
    };
    map = function(fn, array) {
      var item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        _results.push(fn(item));
      }
      return _results;
    };
    remap = function(fn, array) {
      var item, item_idx, _i, _len;
      for (item_idx = _i = 0, _len = array.length; _i < _len; item_idx = ++_i) {
        item = array[item_idx];
        array[item_idx] = fn(item);
      }
      return array;
    };
    invoke = function(method_name, collection) {
      var item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = collection.length; _i < _len; _i++) {
        item = collection[_i];
        _results.push(item[method_name]());
      }
      return _results;
    };
    varynum = function(numbers, start_with_one) {
      var number, variator, _i, _len, _results;
      variator = start_with_one && -1 || 1;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        variator *= -1;
        _results.push(number * variator);
      }
      return _results;
    };
    keys = function() {
      return Object.keys.apply(Object, arguments);
    };
    match = function(source_str, regexp) {
      return source_str.match(regexp);
    };
    str = function() {
      return Array.prototype.join.call(arguments, ' ');
    };
    str_breplace = function(map, str) {
      var regex;
      regex = mk_regexp(str_join('|', keys(map)), 'ig');
      return str.replace(regex, function(seq) {
        return map[seq] || seq;
      });
    };
    str_join = function(join_string, array_to_join) {
      return array_to_join.join(join_string);
    };
    mk_regexp = function(rx_str, rx_settings) {
      rx_settings = rx_settings || "";
      return new RegExp(rx_str, rx_settings);
    };

    /*
    This is a function that iterates with another function 
    over the nodes of a tree structure.
    @param func {function} function that operates on the node.
      signature: son, parent, son_idx, depth
    @param root {hash} a tree whose children lie in the sons
      list (i.e. ordered collection).
    @param depth: indicates depth of recursion
     */
    recurse = function(func, root, depth) {
      var idx, son, sons, _i, _j, _len, _len1;
      if (depth == null) {
        depth = 0;
      }
      sons = root.sons;
      for (idx = _i = 0, _len = sons.length; _i < _len; idx = ++_i) {
        son = sons[idx];
        func(son, root, idx, depth + 1);
      }
      for (_j = 0, _len1 = sons.length; _j < _len1; _j++) {
        son = sons[_j];
        recurse(func, son, depth + 1);
      }
      return root;
    };
    return {
      apply: apply,
      bind: bind,
      cat: cat,
      compose: compose,
      complement: complement,
      contains: contains,
      count: count,
      each: each,
      fastbind: bind,
      flow: flow,
      first: first,
      invoke: invoke,
      is_empty: is_empty,
      is_function: is_function,
      keys: keys,
      last: last,
      list_compact: list_compact,
      map: map,
      match: match,
      mk_regexp: mk_regexp,
      not_empty: not_empty,
      not_function: not_function,
      partial: partial,
      recurse: recurse,
      remap: remap,
      slice: slice,
      str: str,
      str_breplace: str_breplace,
      str_join: str_join,
      varynum: varynum
    };
  };

  if (('undefined' !== typeof define) && define.amd) {
    define(wrapper);
  } else if (('undefined' !== typeof module) && module.exports) {
    module.exports = wrapper();
  }

}).call(this);
