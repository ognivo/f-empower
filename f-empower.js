// Generated by CoffeeScript 1.7.1

/*
  F-EMPOWER
  A set of functions to harness the power and benefits of functional
  programming in JS.
  Author: Ivan Fedorov <sharp.maestro@gmail.com>
  License: MIT
 */
var wrapper,
  __slice = [].slice;

wrapper = function() {
  var Errors, a_contains, a_each, a_filter, a_map, a_reduce, a_reject, apply, bind, butlast, cat, compact, complement, compose, contains, count, each, filter, first, flow, invoke, is_array, is_empty, is_function, jquery_wrap_to_array, keys, last, list, list_compact, map, match, mk_regexp, native_slice, not_array, not_empty, not_function, o_map, partial, pluck, read, recurse, reduce, reject, remap, second, slice, str, str_breplace, str_join, varynum;
  Errors = {
    NOT_FUNCTION: new TypeError('Something is not function')
  };
  native_slice = Array.prototype.slice;
  slice = function(array_or_arguments, start_idx, end_idx) {
    return native_slice.call(array_or_arguments, start_idx, end_idx);
  };
  bind = function(fn, this_arg) {
    var other_args;
    other_args = slice(arguments, 2);
    return arguments.length <= 2 && (function() {
      return fn.apply(this_arg, arguments);
    }) || (function() {
      return fn.apply(this_arg, other_args.concat(slice(arguments)));
    });
  };
  partial = function() {
    var args, fn;
    fn = arguments[0];
    args = slice(arguments, 1);
    return function() {
      return fn.apply(null, args.concat(slice(arguments)));
    };
  };
  apply = function(fn, args_list) {
    return fn.apply(null, args_list);
  };
  compose = function() {
    var functions, item, _i, _len;
    functions = arguments;
    for (_i = 0, _len = functions.length; _i < _len; _i++) {
      item = functions[_i];
      if (not_function(item)) {
        throw Errors.NOT_FUNCTION;
      }
    }
    return function() {
      var i, memo;
      memo = arguments;
      i = functions.length;
      while (--i >= 0) {
        memo = [functions[i].apply(null, memo)];
      }
      return first(memo);
    };
  };
  complement = function(predicate) {
    return function() {
      return !(apply(predicate, arguments));
    };
  };
  flow = function() {
    var functions, item, _i, _len;
    functions = arguments;
    for (_i = 0, _len = functions.length; _i < _len; _i++) {
      item = functions[_i];
      if (not_function(item)) {
        throw Errors.NOT_FUNCTION;
      }
    }
    return function() {
      var i, len, memo;
      memo = arguments;
      len = functions.length;
      i = -1;
      while (++i < len) {
        memo = [functions[i].apply(null, memo)];
      }
      return first(memo);
    };
  };
  is_array = Array.isArray;
  is_empty = function(seq) {
    return seq.length === 0;
  };
  is_function = function(candidate) {
    return 'function' === typeof candidate;
  };
  not_array = complement(is_array);
  not_empty = complement(is_empty);
  not_function = complement(is_function);
  butlast = function(array) {
    return slice(array, 0, array.length - 1);
  };
  cat = function(array) {
    return array.concat.apply(array, slice(arguments, 1));
  };
  contains = function(searched_item, array) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  a_contains = function(array, searched_item) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  a_each = function(array, fn) {
    return each(fn, array);
  };
  a_filter = function(array, fn) {
    return filter(fn, array);
  };
  a_map = function(array, fn) {
    return map(fn, array);
  };
  a_reduce = function(array, fn, val) {
    return reduce(fn, val, array);
  };
  a_reject = function(array, fn) {
    return reject(fn, array);
  };
  compact = function(coll) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = coll.length; _i < _len; _i++) {
      item = coll[_i];
      if (item) {
        _results.push(item);
      }
    }
    return _results;
  };
  count = function(array) {
    return array.length;
  };
  each = function(fn, array) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      fn(item);
    }
  };
  first = function(array) {
    return array[0];
  };
  filter = function(fn, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (fn(item)) {
        _results.push(item);
      }
    }
    return _results;
  };
  last = function(list) {
    return list[list.length - 1];
  };
  list = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return args;
  };
  list_compact = function() {
    var arg, result, _i, _len;
    result = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      arg = arguments[_i];
      if (!!arg) {
        result.push(arg);
      }
    }
    return result;
  };
  map = function(fn, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      _results.push(fn(item));
    }
    return _results;
  };
  reduce = function(fn, val, array) {
    var idx;
    idx = -1;
    if (!array && (is_array(val))) {
      array = val;
      val = fn(array[0], array[1]);
      idx = 1;
    }
    while (++idx < array.length) {
      val = fn(val, array[idx]);
    }
    return val;
  };
  reject = function(fn, array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (!(fn(item))) {
        _results.push(item);
      }
    }
    return _results;
  };
  remap = function(fn, array) {
    var item, item_idx, _i, _len;
    for (item_idx = _i = 0, _len = array.length; _i < _len; item_idx = ++_i) {
      item = array[item_idx];
      array[item_idx] = fn(item);
    }
    return array;
  };
  second = function(array) {
    return array[1];
  };
  invoke = function(method_name, coll) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = coll.length; _i < _len; _i++) {
      item = coll[_i];
      _results.push(item[method_name]());
    }
    return _results;
  };
  pluck = function(prop_name, coll) {
    return map(partial(read, prop_name), coll);
  };
  varynum = function(numbers, start_with_one) {
    var number, variator, _i, _len, _results;
    variator = start_with_one && -1 || 1;
    _results = [];
    for (_i = 0, _len = numbers.length; _i < _len; _i++) {
      number = numbers[_i];
      variator *= -1;
      _results.push(number * variator);
    }
    return _results;
  };
  keys = function(obj) {
    return Object.keys(obj);
  };
  o_map = function(hash, keys_list) {
    var key, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = keys_list.length; _i < _len; _i++) {
      key = keys_list[_i];
      _results.push(hash[key]);
    }
    return _results;
  };
  match = function(source_str, regexp) {
    return source_str.match(regexp);
  };
  str = function() {
    return Array.prototype.join.call(arguments, ' ');
  };
  str_breplace = function(map, str) {
    var regex;
    regex = mk_regexp(str_join('|', keys(map)), 'ig');
    return str.replace(regex, function(seq) {
      return map[seq] || seq;
    });
  };
  str_join = function(join_string, array_to_join) {
    return array_to_join.join(join_string);
  };
  jquery_wrap_to_array = function(jquery_wrap) {
    var i, wrap_len, _results;
    wrap_len = jquery_wrap.length;
    i = -1;
    _results = [];
    while (++i < wrap_len) {
      _results.push(jquery_wrap.eq(i));
    }
    return _results;
  };
  mk_regexp = function(rx_str, rx_settings) {
    rx_settings = rx_settings || "";
    return new RegExp(rx_str, rx_settings);
  };
  read = function(prop_name, hash) {
    return hash[prop_name];
  };

  /*
  This is a function that iterates with another function 
  over the nodes of a tree structure.
  @param func {function} function that operates on the node.
    signature: son, parent, son_idx, depth
  @param root {hash} a tree whose children lie in the sons
    list (i.e. ordered collection).
  @param depth: indicates depth of recursion
   */
  recurse = function(func, root, depth) {
    var idx, son, sons, _i, _j, _len, _len1;
    if (depth == null) {
      depth = 0;
    }
    sons = root.sons;
    for (idx = _i = 0, _len = sons.length; _i < _len; idx = ++_i) {
      son = sons[idx];
      func(son, root, idx, depth + 1);
    }
    for (_j = 0, _len1 = sons.length; _j < _len1; _j++) {
      son = sons[_j];
      recurse(func, son, depth + 1);
    }
    return root;
  };
  return {
    a_contains: a_contains,
    a_each: a_each,
    a_filter: a_filter,
    a_map: a_map,
    a_reduce: a_reduce,
    a_reject: a_reject,
    apply: apply,
    bind: bind,
    butlast: butlast,
    cat: cat,
    compact: compact,
    compose: compose,
    complement: complement,
    contains: contains,
    count: count,
    each: each,
    fastbind: bind,
    flow: flow,
    first: first,
    filter: filter,
    invoke: invoke,
    is_array: is_array,
    is_empty: is_empty,
    is_function: is_function,
    jquery_wrap_to_array: jquery_wrap_to_array,
    keys: keys,
    last: last,
    list: list,
    list_compact: list_compact,
    map: map,
    match: match,
    mk_regexp: mk_regexp,
    not_array: not_array,
    not_empty: not_empty,
    not_function: not_function,
    o_map: o_map,
    partial: partial,
    pluck: pluck,
    read: read,
    recurse: recurse,
    reduce: reduce,
    reject: reject,
    remap: remap,
    second: second,
    slice: slice,
    str: str,
    str_breplace: str_breplace,
    str_join: str_join,
    varynum: varynum
  };
};

if (('undefined' !== typeof define) && define.amd) {
  define(wrapper);
} else if (('undefined' !== typeof module) && module.exports) {
  module.exports = wrapper();
}
